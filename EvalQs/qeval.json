[
    {
        "id": 17,
        "question": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n**Example 1:**\n\n**Input:** digits =  \"23 \"\n**Output:** \\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n\n**Example 2:**\n\n**Input:** digits =  \" \"\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** digits =  \"2 \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]\n\n**Constraints:**\n\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.",
        "difficulty": "Medium"
    },
    {
        "id": 29,
        "question": "Given two integers `dividend` and `divisor`, divide two integers **without** using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`.\n\nReturn _the **quotient** after dividing_ `dividend` _by_ `divisor`.\n\n**Note:** Assume we are dealing with an environment that could only store integers within the **32-bit** signed integer range: `[-231, 231 - 1]`. For this problem, if the quotient is **strictly greater than** `231 - 1`, then return `231 - 1`, and if the quotient is **strictly less than** `-231`, then return `-231`.\n\n**Example 1:**\n\n**Input:** dividend = 10, divisor = 3\n**Output:** 3\n**Explanation:** 10/3 = 3.33333.. which is truncated to 3.\n\n**Example 2:**\n\n**Input:** dividend = 7, divisor = -3\n**Output:** -2\n**Explanation:** 7/-3 = -2.33333.. which is truncated to -2.\n\n**Constraints:**\n\n*   `-231 <= dividend, divisor <= 231 - 1`\n*   `divisor != 0`",
        "difficulty": "Medium"
    },
    {
        "id": 32,
        "question": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.\n\n**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.",
        "difficulty": "Hard"
    },
    {
        "id": 61,
        "question": "Given the `head` of a linked list, rotate the list to the right by `k` places.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[4,5,1,2,3\\]\n\n**Example 2:**\n\n**Input:** head = \\[0,1,2\\], k = 4\n**Output:** \\[2,0,1\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 500]`.\n*   `-100 <= Node.val <= 100`\n*   `0 <= k <= 2 * 109`",
        "difficulty": "Medium"
    },
    {
        "id": 78,
        "question": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[\\[\\],\\[1\\],\\[2\\],\\[1,2\\],\\[3\\],\\[1,3\\],\\[2,3\\],\\[1,2,3\\]\\]\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[\\[\\],\\[0\\]\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `-10 <= nums[i] <= 10`\n*   All the numbers of `nums` are **unique**.",
        "difficulty": "Medium"
    },
    {
        "id": 80,
        "question": "Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_ `k` _slots of_ `nums`.\n\nDo **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1,2,2,3\\]\n**Output:** 5, nums = \\[1,1,2,2,3,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,1,2,3,3\\]\n**Output:** 7, nums = \\[0,0,1,1,2,3,3,\\_,\\_\\]\n**Explanation:** Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in **non-decreasing** order.",
        "difficulty": "Medium"
    },
    {
        "id": 82,
        "question": "Given the `head` of a sorted linked list, _delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list_. Return _the linked list **sorted** as well_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,3,4,4,5\\]\n**Output:** \\[1,2,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[1,1,1,2,3\\]\n**Output:** \\[2,3\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 300]`.\n*   `-100 <= Node.val <= 100`\n*   The list is guaranteed to be **sorted** in ascending order.",
        "difficulty": "Medium"
    },
    {
        "id": 85,
        "question": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
        "difficulty": "Hard"
    },
    {
        "id": 86,
        "question": "Given the `head` of a linked list and a value `x`, partition it such that all nodes **less than** `x` come before nodes **greater than or equal** to `x`.\n\nYou should **preserve** the original relative order of the nodes in each of the two partitions.\n\n**Example 1:**\n\n**Input:** head = \\[1,4,3,2,5,2\\], x = 3\n**Output:** \\[1,2,2,4,3,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[2,1\\], x = 2\n**Output:** \\[1,2\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 200]`.\n*   `-100 <= Node.val <= 100`\n*   `-200 <= x <= 200`",
        "difficulty": "Medium"
    },
    {
        "id": 89,
        "question": "An **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n*   Every integer is in the **inclusive** range `[0, 2n - 1]`,\n*   The first integer is `0`,\n*   An integer appears **no more than once** in the sequence,\n*   The binary representation of every pair of **adjacent** integers differs by **exactly one bit**, and\n*   The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n`, return _any valid **n-bit gray code sequence**_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,3,2\\]\n**Explanation:**\nThe binary representation of \\[0,1,3,2\\] is \\[00,01,11,10\\].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\\[0,2,3,1\\] is also a valid gray code sequence, whose binary representation is \\[00,10,11,01\\].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[0,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 16`",
        "difficulty": "Medium"
    },
    {
        "id": 94,
        "question": "Given the `root` of a binary tree, return _the inorder traversal of its nodes' values_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,3,2\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?",
        "difficulty": "Easy"
    },
    {
        "id": 97,
        "question": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n*   `s = s1 + s2 + ... + sn`\n*   `t = t1 + t2 + ... + tm`\n*   `|n - m| <= 1`\n*   The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`.\n\n**Example 1:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbcbcac \"\n**Output:** true\n**Explanation:** One way to obtain s3 is:\nSplit s1 into s1 =  \"aa \" +  \"bc \" +  \"c \", and s2 into s2 =  \"dbbc \" +  \"a \".\nInterleaving the two splits, we get  \"aa \" +  \"dbbc \" +  \"bc \" +  \"a \" +  \"c \" =  \"aadbbcbcac \".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbbaccc \"\n**Output:** false\n**Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n**Example 3:**\n\n**Input:** s1 =  \" \", s2 =  \" \", s3 =  \" \"\n**Output:** true\n\n**Constraints:**\n\n*   `0 <= s1.length, s2.length <= 100`\n*   `0 <= s3.length <= 200`\n*   `s1`, `s2`, and `s3` consist of lowercase English letters.\n\n**Follow up:** Could you solve it using only `O(s2.length)` additional memory space?",
        "difficulty": "Medium"
    },
    {
        "id": 107,
        "question": "Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[15,7\\],\\[9,20\\],\\[3\\]\\]\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[\\[1\\]\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-1000 <= Node.val <= 1000`",
        "difficulty": "Medium"
    },
    {
        "id": 112,
        "question": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\n\nA **leaf** is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n**Example 3:**\n\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`",
        "difficulty": "Easy"
    },
    {
        "id": 122,
        "question": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.\n\n**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`",
        "difficulty": "Medium"
    },
    {
        "id": 123,
        "question": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`",
        "difficulty": "Hard"
    },
    {
        "id": 125,
        "question": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** s =  \"A man, a plan, a canal: Panama \"\n**Output:** true\n**Explanation:**  \"amanaplanacanalpanama \" is a palindrome.\n\n**Example 2:**\n\n**Input:** s =  \"race a car \"\n**Output:** false\n**Explanation:**  \"raceacar \" is not a palindrome.\n\n**Example 3:**\n\n**Input:** s =  \"  \"\n**Output:** true\n**Explanation:** s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.",
        "difficulty": "Easy"
    },
    {
        "id": 130,
        "question": "Given an `m x n` matrix `board` containing `'X'` and `'O'`, _capture all regions that are 4-directionally surrounded by_ `'X'`.\n\nA region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"X \"\\],\\[ \"X \", \"X \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Output:** \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Explanation:** Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \"X \"\\]\\]\n**Output:** \\[\\[ \"X \"\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is `'X'` or `'O'`.",
        "difficulty": "Medium"
    },
    {
        "id": 133,
        "question": "Given a reference of a node in a **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.\n\nReturn a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n\nclass Node {\n    public int val;\n    public List neighbors;\n}\n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.\n\n**Example 1:**\n\n**Input:** adjList = \\[\\[2,4\\],\\[1,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Output:** \\[\\[2,4\\],\\[1,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Explanation:** There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n**Example 2:**\n\n**Input:** adjList = \\[\\[\\]\\]\n**Output:** \\[\\[\\]\\]\n**Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n**Example 3:**\n\n**Input:** adjList = \\[\\]\n**Output:** \\[\\]\n**Explanation:** This an empty graph, it does not have any nodes.\n\n**Constraints:**\n\n*   The number of nodes in the graph is in the range `[0, 100]`.\n*   `1 <= Node.val <= 100`\n*   `Node.val` is unique for each node.\n*   There are no repeated edges and no self-loops in the graph.\n*   The Graph is connected and all nodes can be visited starting from the given node.",
        "difficulty": "Medium"
    },
    {
        "id": 141,
        "question": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n**Example 2:**\n\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n\n**Example 3:**\n\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list.\n\n**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?",
        "difficulty": "Easy"
    },
    {
        "id": 144,
        "question": "Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,2,3\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?",
        "difficulty": "Easy"
    },
    {
        "id": 145,
        "question": "Given the `root` of a binary tree, return _the postorder traversal of its nodes' values_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[3,2,1\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of the nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?",
        "difficulty": "Easy"
    },
    {
        "id": 148,
        "question": "Given the `head` of a linked list, return _the list after sorting it in **ascending order**_.\n\n**Example 1:**\n\n**Input:** head = \\[4,2,1,3\\]\n**Output:** \\[1,2,3,4\\]\n\n**Example 2:**\n\n**Input:** head = \\[-1,5,3,4,0\\]\n**Output:** \\[-1,0,3,4,5\\]\n\n**Example 3:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 5 * 104]`.\n*   `-105 <= Node.val <= 105`\n\n**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?",
        "difficulty": "Medium"
    },
    {
        "id": 150,
        "question": "You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nEvaluate the expression. Return _an integer that represents the value of the expression_.\n\n**Note** that:\n\n*   The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Each operand may be an integer or another expression.\n*   The division between two integers always **truncates toward zero**.\n*   There will not be any division by zero.\n*   The input represents a valid arithmetic expression in a reverse polish notation.\n*   The answer and all the intermediate calculations can be represented in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** tokens = \\[ \"2 \", \"1 \", \"+ \", \"3 \", \"\\* \"\\]\n**Output:** 9\n**Explanation:** ((2 + 1) \\* 3) = 9\n\n**Example 2:**\n\n**Input:** tokens = \\[ \"4 \", \"13 \", \"5 \", \"/ \", \"+ \"\\]\n**Output:** 6\n**Explanation:** (4 + (13 / 5)) = 6\n\n**Example 3:**\n\n**Input:** tokens = \\[ \"10 \", \"6 \", \"9 \", \"3 \", \"+ \", \"-11 \", \"\\* \", \"/ \", \"\\* \", \"17 \", \"+ \", \"5 \", \"+ \"\\]\n**Output:** 22\n**Explanation:** ((10 \\* (6 / ((9 + 3) \\* -11))) + 17) + 5\n= ((10 \\* (6 / (12 \\* -11))) + 17) + 5\n= ((10 \\* (6 / -132)) + 17) + 5\n= ((10 \\* 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n**Constraints:**\n\n*   `1 <= tokens.length <= 104`\n*   `tokens[i]` is either an operator: `\"+ \"`, `\"- \"`, `\"* \"`, or `\"/ \"`, or an integer in the range `[-200, 200]`.",
        "difficulty": "Medium"
    },
    {
        "id": 168,
        "question": "Given an integer `columnNumber`, return _its corresponding column title as it appears in an Excel sheet_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n**Example 1:**\n\n**Input:** columnNumber = 1\n**Output:**  \"A \"\n\n**Example 2:**\n\n**Input:** columnNumber = 28\n**Output:**  \"AB \"\n\n**Example 3:**\n\n**Input:** columnNumber = 701\n**Output:**  \"ZY \"\n\n**Constraints:**\n\n*   `1 <= columnNumber <= 231 - 1`",
        "difficulty": "Easy"
    },
    {
        "id": 172,
        "question": "Given an integer `n`, return _the number of trailing zeroes in_ `n!`.\n\nNote that `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 0\n**Explanation:** 3! = 6, no trailing zero.\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** 1\n**Explanation:** 5! = 120, one trailing zero.\n\n**Example 3:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= n <= 104`\n\n**Follow up:** Could you write a solution that works in logarithmic time complexity?",
        "difficulty": "Medium"
    },
    {
        "id": 205,
        "question": "Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n**Example 1:**\n\n**Input:** s = \"egg\", t = \"add\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"foo\", t = \"bar\"\n**Output:** false\n\n**Example 3:**\n\n**Input:** s = \"paper\", t = \"title\"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `t.length == s.length`\n*   `s` and `t` consist of any valid ascii character.",
        "difficulty": "Easy"
    },
    {
        "id": 207,
        "question": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n**Example 2:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= 5000`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   All the pairs prerequisites\\[i\\] are **unique**.",
        "difficulty": "Medium"
    },
    {
        "id": 208,
        "question": "A [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as \"try \") or **prefix tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n*   `Trie()` Initializes the trie object.\n*   `void insert(String word)` Inserts the string `word` into the trie.\n*   `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n*   `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.\n\n**Example 1:**\n\n**Input**\n\\[ \"Trie \",  \"insert \",  \"search \",  \"search \",  \"startsWith \",  \"insert \",  \"search \"\\]\n\\[\\[\\], \\[ \"apple \"\\], \\[ \"apple \"\\], \\[ \"app \"\\], \\[ \"app \"\\], \\[ \"app \"\\], \\[ \"app \"\\]\\]\n**Output**\n\\[null, null, true, false, true, null, true\\]\n\n**Explanation**\nTrie trie = new Trie();\ntrie.insert( \"apple \");\ntrie.search( \"apple \");   // return True\ntrie.search( \"app \");     // return False\ntrie.startsWith( \"app \"); // return True\ntrie.insert( \"app \");\ntrie.search( \"app \");     // return True\n\n**Constraints:**\n\n*   `1 <= word.length, prefix.length <= 2000`\n*   `word` and `prefix` consist only of lowercase English letters.\n*   At most `3 * 104` calls **in total** will be made to `insert`, `search`, and `startsWith`.",
        "difficulty": "Medium"
    },
    {
        "id": 226,
        "question": "Given the `root` of a binary tree, invert the tree, and return _its root_.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3,6,9\\]\n**Output:** \\[4,7,2,9,6,3,1\\]\n\n**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,3,1\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`",
        "difficulty": "Easy"
    },
    {
        "id": 228,
        "question": "You are given a **sorted unique** integer array `nums`.\n\nA **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive).\n\nReturn _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,4,5,7\\]\n**Output:** \\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n**Explanation:** The ranges are:\n\\[0,2\\] -->  \"0->2 \"\n\\[4,5\\] -->  \"4->5 \"\n\\[7,7\\] -->  \"7 \"\n\n**Example 2:**\n\n**Input:** nums = \\[0,2,3,4,6,8,9\\]\n**Output:** \\[ \"0 \", \"2->4 \", \"6 \", \"8->9 \"\\]\n**Explanation:** The ranges are:\n\\[0,0\\] -->  \"0 \"\n\\[2,4\\] -->  \"2->4 \"\n\\[6,6\\] -->  \"6 \"\n\\[8,9\\] -->  \"8->9 \"\n\n**Constraints:**\n\n*   `0 <= nums.length <= 20`\n*   `-231 <= nums[i] <= 231 - 1`\n*   All the values of `nums` are **unique**.\n*   `nums` is sorted in ascending order.",
        "difficulty": "Easy"
    },
    {
        "id": 230,
        "question": "Given the `root` of a binary search tree, and an integer `k`, return _the_ `kth` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.\n\n**Example 1:**\n\n**Input:** root = \\[3,1,4,null,2\\], k = 1\n**Output:** 1\n\n**Example 2:**\n\n**Input:** root = \\[5,3,6,2,4,null,null,1\\], k = 3\n**Output:** 3\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`\n*   `0 <= Node.val <= 104`\n\n**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
        "difficulty": "Medium"
    },
    {
        "id": 234,
        "question": "Given the `head` of a singly linked list, return `true` _if it is a_ _palindrome_ _or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,2,1\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 105]`.\n*   `0 <= Node.val <= 9`\n\n**Follow up:** Could you do it in `O(n)` time and `O(1)` space?",
        "difficulty": "Easy"
    },
    {
        "id": 242,
        "question": "Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n**Example 1:**\n\n**Input:** s = \"anagram\", t = \"nagaram\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"rat\", t = \"car\"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 5 * 104`\n*   `s` and `t` consist of lowercase English letters.\n\n**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "difficulty": "Easy"
    },
    {
        "id": 252,
        "question": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** false\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** true\n\n**Constraints:**\n\n*   `0 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 106`",
        "difficulty": "Easy"
    },
    {
        "id": 266,
        "question": "Given a string `s`, return `true` _if a permutation of the string could form a_ _**palindrome**_ _and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** s =  \"code \"\n**Output:** false\n\n**Example 2:**\n\n**Input:** s =  \"aab \"\n**Output:** true\n\n**Example 3:**\n\n**Input:** s =  \"carerac \"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 5000`\n*   `s` consists of only lowercase English letters.",
        "difficulty": "Easy"
    },
    {
        "id": 273,
        "question": "Convert a non-negative integer `num` to its English words representation.\n\n**Example 1:**\n\n**Input:** num = 123\n**Output:**  \"One Hundred Twenty Three \"\n\n**Example 2:**\n\n**Input:** num = 12345\n**Output:**  \"Twelve Thousand Three Hundred Forty Five \"\n\n**Example 3:**\n\n**Input:** num = 1234567\n**Output:**  \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven \"\n\n**Constraints:**\n\n*   `0 <= num <= 231 - 1`",
        "difficulty": "Hard"
    },
    {
        "id": 287,
        "question": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in `nums`, return _this repeated number_.\n\nYou must solve the problem **without** modifying the array `nums` and uses only constant extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,4,2,2\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** nums = \\[3,1,3,4,2\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `nums.length == n + 1`\n*   `1 <= nums[i] <= n`\n*   All the integers in `nums` appear only **once** except for **precisely one integer** which appears **two or more** times.\n\n**Follow up:**\n\n*   How can we prove that at least one duplicate number must exist in `nums`?\n*   Can you solve the problem in linear runtime complexity?",
        "difficulty": "Medium"
    },
    {
        "id": 290,
        "question": "Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.\n\n**Example 1:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat dog \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat fish \"\n**Output:** false\n\n**Example 3:**\n\n**Input:** pattern =  \"aaaa \", s =  \"dog cat cat dog \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= pattern.length <= 300`\n*   `pattern` contains only lower-case English letters.\n*   `1 <= s.length <= 3000`\n*   `s` contains only lowercase English letters and spaces `' '`.\n*   `s` **does not contain** any leading or trailing spaces.\n*   All the words in `s` are separated by a **single space**.",
        "difficulty": "Easy"
    },
    {
        "id": 310,
        "question": "A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.",
        "difficulty": "Medium"
    },
    {
        "id": 316,
        "question": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n**Example 1:**\n\n**Input:** s =  \"bcabc \"\n**Output:**  \"abc \"\n\n**Example 2:**\n\n**Input:** s =  \"cbacdcbc \"\n**Output:**  \"acdb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n\n**Note:** This question is the same as 1081: [https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)",
        "difficulty": "Medium"
    },
    {
        "id": 322,
        "question": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`",
        "difficulty": "Medium"
    },
    {
        "id": 323,
        "question": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.",
        "difficulty": "Medium"
    },
    {
        "id": 342,
        "question": "Given an integer `n`, return _`true` if it is a power of four. Otherwise, return `false`_.\n\nAn integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`.\n\n**Example 1:**\n\n**Input:** n = 16\n**Output:** true\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** false\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** true\n\n**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**Follow up:** Could you solve it without loops/recursion?",
        "difficulty": "Easy"
    },
    {
        "id": 350,
        "question": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2,2\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[4,9\\]\n**Explanation:** \\[9,4\\] is also accepted.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`\n\n**Follow up:**\n\n*   What if the given array is already sorted? How would you optimize your algorithm?\n*   What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n*   What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?",
        "difficulty": "Easy"
    },
    {
        "id": 357,
        "question": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 91\n**Explanation:** The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 8`",
        "difficulty": "Medium"
    },
    {
        "id": 393,
        "question": "Given an integer array `data` representing the data, return whether it is a valid **UTF-8** encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in **UTF8** can be from **1 to 4 bytes** long, subjected to the following rules:\n\n1.  For a **1-byte** character, the first bit is a `0`, followed by its Unicode code.\n2.  For an **n-bytes** character, the first `n` bits are all one's, the `n + 1` bit is `0`, followed by `n - 1` bytes with the most significant `2` bits being `10`.\n\nThis is how the UTF-8 encoding would work:\n\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n`x` denotes a bit in the binary form of a byte that may be either `0` or `1`.\n\n**Note:** The input is an array of integers. Only the **least significant 8 bits** of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\n**Example 1:**\n\n**Input:** data = \\[197,130,1\\]\n**Output:** true\n**Explanation:** data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\n**Example 2:**\n\n**Input:** data = \\[235,140,4\\]\n**Output:** false\n**Explanation:** data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n\n**Constraints:**\n\n*   `1 <= data.length <= 2 * 104`\n*   `0 <= data[i] <= 255`",
        "difficulty": "Medium"
    },
    {
        "id": 397,
        "question": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
        "difficulty": "Medium"
    },
    {
        "id": 405,
        "question": "Given an integer `num`, return _a string representing its hexadecimal representation_. For negative integers, [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) method is used.\n\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\n\n**Note:** You are not allowed to use any built-in library method to directly solve this problem.\n\n**Example 1:**\n\n**Input:** num = 26\n**Output:** \"1a\"\n\n**Example 2:**\n\n**Input:** num = -1\n**Output:** \"ffffffff\"\n\n**Constraints:**\n\n*   `-231 <= num <= 231 - 1`",
        "difficulty": "Easy"
    },
    {
        "id": 478,
        "question": "Given the radius and the position of the center of a circle, implement the function `randPoint` which generates a uniform random point inside the circle.\n\nImplement the `Solution` class:\n\n*   `Solution(double radius, double x_center, double y_center)` initializes the object with the radius of the circle `radius` and the position of the center `(x_center, y_center)`.\n*   `randPoint()` returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array `[x, y]`.\n\n**Example 1:**\n\n**Input**\n\\[ \"Solution \",  \"randPoint \",  \"randPoint \",  \"randPoint \"\\]\n\\[\\[1.0, 0.0, 0.0\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, \\[-0.02493, -0.38077\\], \\[0.82314, 0.38945\\], \\[0.36572, 0.17248\\]\\]\n\n**Explanation**\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return \\[-0.02493, -0.38077\\]\nsolution.randPoint(); // return \\[0.82314, 0.38945\\]\nsolution.randPoint(); // return \\[0.36572, 0.17248\\]\n\n**Constraints:**\n\n*   `0 < radius <= 108`\n*   `-107 <= x_center, y_center <= 107`\n*   At most `3 * 104` calls will be made to `randPoint`.",
        "difficulty": "Medium"
    },
    {
        "id": 495,
        "question": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.\n\nReturn _the **total** number of seconds that Ashe is poisoned_.\n\n**Example 1:**\n\n**Input:** timeSeries = \\[1,4\\], duration = 2\n**Output:** 4\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n\n**Example 2:**\n\n**Input:** timeSeries = \\[1,2\\], duration = 2\n**Output:** 3\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.\n\n**Constraints:**\n\n*   `1 <= timeSeries.length <= 104`\n*   `0 <= timeSeries[i], duration <= 107`\n*   `timeSeries` is sorted in **non-decreasing** order.",
        "difficulty": "Easy"
    },
    {
        "id": 503,
        "question": "Given a circular integer array `nums` (i.e., the next element of `nums[nums.length - 1]` is `nums[0]`), return _the **next greater number** for every element in_ `nums`.\n\nThe **next greater number** of a number `x` is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return `-1` for this number.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,1\\]\n**Output:** \\[2,-1,2\\]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number. \nThe second 1's next greater number needs to search circularly, which is also 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,3\\]\n**Output:** \\[2,3,4,-1,4\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`",
        "difficulty": "Medium"
    },
    {
        "id": 507,
        "question": "A [**perfect number**](https://en.wikipedia.org/wiki/Perfect_number) is a **positive integer** that is equal to the sum of its **positive divisors**, excluding the number itself. A **divisor** of an integer `x` is an integer that can divide `x` evenly.\n\nGiven an integer `n`, return `true` _if_ `n` _is a perfect number, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** num = 28\n**Output:** true\n**Explanation:** 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\n**Example 2:**\n\n**Input:** num = 7\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= num <= 108`",
        "difficulty": "Easy"
    },
    {
        "id": 515,
        "question": "Given the `root` of a binary tree, return _an array of the largest value in each row_ of the tree **(0-indexed)**.\n\n**Example 1:**\n\n**Input:** root = \\[1,3,2,5,3,null,9\\]\n**Output:** \\[1,3,9\\]\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** \\[1,3\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree will be in the range `[0, 104]`.\n*   `-231 <= Node.val <= 231 - 1`",
        "difficulty": "Medium"
    },
    {
        "id": 521,
        "question": "Given two strings `a` and `b`, return _the length of the **longest uncommon subsequence** between_ `a` _and_ `b`. If the longest uncommon subsequence does not exist, return `-1`.\n\nAn **uncommon subsequence** between two strings is a string that is a **subsequence of one but not the other**.\n\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string).\n\n**Example 1:**\n\n**Input:** a =  \"aba \", b =  \"cdc \"\n**Output:** 3\n**Explanation:** One longest uncommon subsequence is  \"aba \" because  \"aba \" is a subsequence of  \"aba \" but not  \"cdc \".\nNote that  \"cdc \" is also a longest uncommon subsequence.\n\n**Example 2:**\n\n**Input:** a =  \"aaa \", b =  \"bbb \"\n**Output:** 3\n**Explanation:** The longest uncommon subsequences are  \"aaa \" and  \"bbb \".\n\n**Example 3:**\n\n**Input:** a =  \"aaa \", b =  \"aaa \"\n**Output:** -1\n**Explanation:** Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\n\n**Constraints:**\n\n*   `1 <= a.length, b.length <= 100`\n*   `a` and `b` consist of lower-case English letters.",
        "difficulty": "Easy"
    },
    {
        "id": 543,
        "question": "Given the `root` of a binary tree, return _the length of the **diameter** of the tree_.\n\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.\n\nThe **length** of a path between two nodes is represented by the number of edges between them.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5\\]\n**Output:** 3\n**Explanation:** 3 is the length of the path \\[4,2,1,3\\] or \\[5,2,1,3\\].\n\n**Example 2:**\n\n**Input:** root = \\[1,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-100 <= Node.val <= 100`",
        "difficulty": "Easy"
    },
    {
        "id": 605,
        "question": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.\n\nGiven an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` _if_ `n` _new flowers can be planted in the_ `flowerbed` _without violating the no-adjacent-flowers rule and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 1\n**Output:** true\n\n**Example 2:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 2\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= flowerbed.length <= 2 * 104`\n*   `flowerbed[i]` is `0` or `1`.\n*   There are no two adjacent flowers in `flowerbed`.\n*   `0 <= n <= flowerbed.length`",
        "difficulty": "Easy"
    },
    {
        "id": 617,
        "question": "You are given two binary trees `root1` and `root2`.\n\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n\nReturn _the merged tree_.\n\n**Note:** The merging process must start from the root nodes of both trees.\n\n**Example 1:**\n\n**Input:** root1 = \\[1,3,2,5\\], root2 = \\[2,1,3,null,4,null,7\\]\n**Output:** \\[3,4,5,5,4,null,7\\]\n\n**Example 2:**\n\n**Input:** root1 = \\[1\\], root2 = \\[1,2\\]\n**Output:** \\[2,2\\]\n\n**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 2000]`.\n*   `-104 <= Node.val <= 104`",
        "difficulty": "Easy"
    },
    {
        "id": 629,
        "question": "For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 3, k = 0\n**Output:** 1\n**Explanation:** Only the array \\[1,2,3\\] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n\n**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 2\n**Explanation:** The array \\[1,3,2\\] and \\[2,1,3\\] have exactly 1 inverse pair.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= k <= 1000`",
        "difficulty": "Hard"
    },
    {
        "id": 647,
        "question": "Given a string `s`, return _the number of **palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 3\n**Explanation:** Three palindromic strings:  \"a \",  \"b \",  \"c \".\n\n**Example 2:**\n\n**Input:** s =  \"aaa \"\n**Output:** 6\n**Explanation:** Six palindromic strings:  \"a \",  \"a \",  \"a \",  \"aa \",  \"aa \",  \"aaa \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters.",
        "difficulty": "Medium"
    },
    {
        "id": 669,
        "question": "Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lies in `[low, high]`. Trimming the tree should **not** change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a **unique answer**.\n\nReturn _the root of the trimmed binary search tree_. Note that the root may change depending on the given bounds.\n\n**Example 1:**\n\n**Input:** root = \\[1,0,2\\], low = 1, high = 2\n**Output:** \\[1,null,2\\]\n\n**Example 2:**\n\n**Input:** root = \\[3,0,4,null,2,null,null,1\\], low = 1, high = 3\n**Output:** \\[3,2,null,1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 104`\n*   The value of each node in the tree is **unique**.\n*   `root` is guaranteed to be a valid binary search tree.\n*   `0 <= low <= high <= 104`",
        "difficulty": "Medium"
    },
    {
        "id": 695,
        "question": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1,0,0,0,0,1,0,0,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,1,1,0,1,0,0,0,0,0,0,0,0\\],\\[0,1,0,0,1,1,0,0,1,0,1,0,0\\],\\[0,1,0,0,1,1,0,0,1,1,1,0,0\\],\\[0,0,0,0,0,0,0,0,0,0,1,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,0,0,0,0\\]\\]\n**Output:** 6\n**Explanation:** The answer is not 11, because the island must be connected 4-directionally.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.",
        "difficulty": "Medium"
    },
    {
        "id": 696,
        "question": "Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n**Example 1:**\n\n**Input:** s =  \"00110011 \"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's:  \"0011 \",  \"01 \",  \"1100 \",  \"10 \",  \"0011 \", and  \"01 \".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso,  \"00110011 \" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n**Example 2:**\n\n**Input:** s =  \"10101 \"\n**Output:** 4\n**Explanation:** There are 4 substrings:  \"10 \",  \"01 \",  \"10 \",  \"01 \" that have equal number of consecutive 1's and 0's.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.",
        "difficulty": "Easy"
    },
    {
        "id": 700,
        "question": "You are given the `root` of a binary search tree (BST) and an integer `val`.\n\nFind the node in the BST that the node's value equals `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3\\], val = 2\n**Output:** \\[2,1,3\\]\n\n**Example 2:**\n\n**Input:** root = \\[4,2,7,1,3\\], val = 5\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 5000]`.\n*   `1 <= Node.val <= 107`\n*   `root` is a binary search tree.\n*   `1 <= val <= 107`",
        "difficulty": "Easy"
    },
    {
        "id": 701,
        "question": "You are given the `root` node of a binary search tree (BST) and a `value` to insert into the tree. Return _the root node of the BST after the insertion_. It is **guaranteed** that the new value does not exist in the original BST.\n\n**Notice** that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return **any of them**.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3\\], val = 5\n**Output:** \\[4,2,7,1,3,5\\]\n**Explanation:** Another accepted tree is:\n \n\n**Example 2:**\n\n**Input:** root = \\[40,20,60,10,30,50,70\\], val = 25\n**Output:** \\[40,20,60,10,30,50,70,null,null,25\\]\n\n**Example 3:**\n\n**Input:** root = \\[4,2,7,1,3,null,null,null,null,null,null\\], val = 5\n**Output:** \\[4,2,7,1,3,5\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree will be in the range `[0, 104]`.\n*   `-108 <= Node.val <= 108`\n*   All the values `Node.val` are **unique**.\n*   `-108 <= val <= 108`\n*   It's **guaranteed** that `val` does not exist in the original BST.",
        "difficulty": "Medium"
    },
    {
        "id": 709,
        "question": "Given a string `s`, return _the string after replacing every uppercase letter with the same lowercase letter_.\n\n**Example 1:**\n\n**Input:** s =  \"Hello \"\n**Output:**  \"hello \"\n\n**Example 2:**\n\n**Input:** s =  \"here \"\n**Output:**  \"here \"\n\n**Example 3:**\n\n**Input:** s =  \"LOVELY \"\n**Output:**  \"lovely \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of printable ASCII characters.",
        "difficulty": "Easy"
    },
    {
        "id": 733,
        "question": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.\n\n**Example 1:**\n\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n**Example 2:**\n\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image.\n\n**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`",
        "difficulty": "Easy"
    },
    {
        "id": 760,
        "question": "You are given two integer arrays `nums1` and `nums2` where `nums2` is **an anagram** of `nums1`. Both arrays may contain duplicates.\n\nReturn _an index mapping array_ `mapping` _from_ `nums1` _to_ `nums2` _where_ `mapping[i] = j` _means the_ `ith` _element in_ `nums1` _appears in_ `nums2` _at index_ `j`. If there are multiple answers, return **any of them**.\n\nAn array `a` is **an anagram** of an array `b` means `b` is made by randomizing the order of the elements in `a`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[12,28,46,32,50\\], nums2 = \\[50,12,32,46,28\\]\n**Output:** \\[1,4,3,2,0\\]\n**Explanation:** As mapping\\[0\\] = 1 because the 0th element of nums1 appears at nums2\\[1\\], and mapping\\[1\\] = 4 because the 1st element of nums1 appears at nums2\\[4\\], and so on.\n\n**Example 2:**\n\n**Input:** nums1 = \\[84,46\\], nums2 = \\[84,46\\]\n**Output:** \\[0,1\\]\n\n**Constraints:**\n\n*   `1 <= nums1.length <= 100`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 105`\n*   `nums2` is an anagram of `nums1`.",
        "difficulty": "Easy"
    },
    {
        "id": 835,
        "question": "You are given two images, `img1` and `img2`, represented as binary, square matrices of size `n x n`. A binary matrix has only `0`s and `1`s as values.\n\nWe **translate** one image however we choose by sliding all the `1` bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the **overlap** by counting the number of positions that have a `1` in **both** images.\n\nNote also that a translation does **not** include any kind of rotation. Any `1` bits that are translated outside of the matrix borders are erased.\n\nReturn _the largest possible overlap_.\n\n**Example 1:**\n\n**Input:** img1 = \\[\\[1,1,0\\],\\[0,1,0\\],\\[0,1,0\\]\\], img2 = \\[\\[0,0,0\\],\\[0,1,1\\],\\[0,0,1\\]\\]\n**Output:** 3\n**Explanation:** We translate img1 to right by 1 unit and down by 1 unit.\n \nThe number of positions that have a 1 in both images is 3 (shown in red).\n \n\n**Example 2:**\n\n**Input:** img1 = \\[\\[1\\]\\], img2 = \\[\\[1\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** img1 = \\[\\[0\\]\\], img2 = \\[\\[0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == img1.length == img1[i].length`\n*   `n == img2.length == img2[i].length`\n*   `1 <= n <= 30`\n*   `img1[i][j]` is either `0` or `1`.\n*   `img2[i][j]` is either `0` or `1`.",
        "difficulty": "Medium"
    },
    {
        "id": 841,
        "question": "There are `n` rooms labeled from `0` to `n - 1` and all the rooms are locked except for room `0`. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of **distinct keys** in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array `rooms` where `rooms[i]` is the set of keys that you can obtain if you visited room `i`, return `true` _if you can visit **all** the rooms, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** rooms = \\[\\[1\\],\\[2\\],\\[3\\],\\[\\]\\]\n**Output:** true\n**Explanation:** \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n\n**Example 2:**\n\n**Input:** rooms = \\[\\[1,3\\],\\[3,0,1\\],\\[2\\],\\[0\\]\\]\n**Output:** false\n**Explanation:** We can not enter room number 2 since the only key that unlocks it is in that room.\n\n**Constraints:**\n\n*   `n == rooms.length`\n*   `2 <= n <= 1000`\n*   `0 <= rooms[i].length <= 1000`\n*   `1 <= sum(rooms[i].length) <= 3000`\n*   `0 <= rooms[i][j] < n`\n*   All the values of `rooms[i]` are **unique**.",
        "difficulty": "Medium"
    },
    {
        "id": 865,
        "question": "Given the `root` of a binary tree, the depth of each node is **the shortest distance to the root**.\n\nReturn _the smallest subtree_ such that it contains **all the deepest nodes** in the original tree.\n\nA node is called **the deepest** if it has the largest depth possible among any node in the entire tree.\n\nThe **subtree** of a node is a tree consisting of that node, plus the set of all descendants of that node.\n\n**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\]\n**Output:** \\[2,7,4\\]\n**Explanation:** We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest nodes of the tree.\nNotice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n**Explanation:** The root is the deepest node in the tree.\n\n**Example 3:**\n\n**Input:** root = \\[0,1,3,null,2\\]\n**Output:** \\[2\\]\n**Explanation:** The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.\n\n**Constraints:**\n\n*   The number of nodes in the tree will be in the range `[1, 500]`.\n*   `0 <= Node.val <= 500`\n*   The values of the nodes in the tree are **unique**.\n\n**Note:** This question is the same as 1123: [https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/)",
        "difficulty": "Medium"
    },
    {
        "id": 869,
        "question": "You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.\n\nReturn `true` _if and only if we can do this so that the resulting number is a power of two_.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= n <= 109`",
        "difficulty": "Medium"
    },
    {
        "id": 883,
        "question": "You are given an `n x n` `grid` where we place some `1 x 1 x 1` cubes that are axis-aligned with the `x`, `y`, and `z` axes.\n\nEach value `v = grid[i][j]` represents a tower of `v` cubes placed on top of the cell `(i, j)`.\n\nWe view the projection of these cubes onto the `xy`, `yz`, and `zx` planes.\n\nA **projection** is like a shadow, that maps our **3-dimensional** figure to a **2-dimensional** plane. We are viewing the \"shadow \" when looking at the cubes from the top, the front, and the side.\n\nReturn _the total area of all three projections_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** 17\n**Explanation:** Here are the three projections ( \"shadows \") of the shape made with each axis-aligned plane.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[2\\]\\]\n**Output:** 5\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,2\\]\\]\n**Output:** 8\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] <= 50`",
        "difficulty": "Easy"
    },
    {
        "id": 890,
        "question": "Given a list of strings `words` and a string `pattern`, return _a list of_ `words[i]` _that match_ `pattern`. You may return the answer in **any order**.\n\nA word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.\n\n**Example 1:**\n\n**Input:** words = \\[ \"abc \", \"deq \", \"mee \", \"aqq \", \"dkd \", \"ccc \"\\], pattern =  \"abb \"\n**Output:** \\[ \"mee \", \"aqq \"\\]\n**Explanation:**  \"mee \" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n \"ccc \" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.\n\n**Example 2:**\n\n**Input:** words = \\[ \"a \", \"b \", \"c \"\\], pattern =  \"a \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]\n\n**Constraints:**\n\n*   `1 <= pattern.length <= 20`\n*   `1 <= words.length <= 50`\n*   `words[i].length == pattern.length`\n*   `pattern` and `words[i]` are lowercase English letters.",
        "difficulty": "Medium"
    },
    {
        "id": 905,
        "question": "Given an integer array `nums`, move all the even integers at the beginning of the array followed by all the odd integers.\n\nReturn _**any array** that satisfies this condition_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,1,2,4\\]\n**Output:** \\[2,4,3,1\\]\n**Explanation:** The outputs \\[4,2,3,1\\], \\[2,4,1,3\\], and \\[4,2,1,3\\] would also be accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `0 <= nums[i] <= 5000`",
        "difficulty": "Easy"
    },
    {
        "id": 962,
        "question": "A **ramp** in an integer array `nums` is a pair `(i, j)` for which `i < j` and `nums[i] <= nums[j]`. The **width** of such a ramp is `j - i`.\n\nGiven an integer array `nums`, return _the maximum width of a **ramp** in_ `nums`. If there is no **ramp** in `nums`, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[6,0,8,2,1,5\\]\n**Output:** 4\n**Explanation:** The maximum width ramp is achieved at (i, j) = (1, 5): nums\\[1\\] = 0 and nums\\[5\\] = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[9,8,1,0,1,9,4,0,4,1\\]\n**Output:** 7\n**Explanation:** The maximum width ramp is achieved at (i, j) = (2, 9): nums\\[2\\] = 1 and nums\\[9\\] = 1.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5 * 104`",
        "difficulty": "Medium"
    },
    {
        "id": 999,
        "question": "On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** In this example, the rook is attacking all the pawns.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 0\n**Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n\n**Example 3:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** The rook is attacking the pawns at positions b5, d6, and f5.\n\n**Constraints:**\n\n*   `board.length == 8`\n*   `board[i].length == 8`\n*   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\n*   There is exactly one cell with `board[i][j] == 'R'`",
        "difficulty": "Easy"
    },
    {
        "id": 1005,
        "question": "Given an integer array `nums` and an integer `k`, modify the array in the following way:\n\n*   choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index `i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,3\\], k = 1\n**Output:** 5\n**Explanation:** Choose index 1 and nums becomes \\[4,-2,3\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,-1,0,2\\], k = 3\n**Output:** 6\n**Explanation:** Choose indices (1, 2, 2) and nums becomes \\[3,1,0,2\\].\n\n**Example 3:**\n\n**Input:** nums = \\[2,-3,-1,5,-4\\], k = 2\n**Output:** 13\n**Explanation:** Choose indices (1, 4) and nums becomes \\[2,3,-1,5,4\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-100 <= nums[i] <= 100`\n*   `1 <= k <= 104`",
        "difficulty": "Easy"
    },
    {
        "id": 1006,
        "question": "The **factorial** of a positive integer `n` is the product of all positive integers less than or equal to `n`.\n\n*   For example, `factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1`.\n\nWe make a **clumsy factorial** using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply `'*'`, divide `'/'`, add `'+'`, and subtract `'-'` in this order.\n\n*   For example, `clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1`.\n\nHowever, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\n\nAdditionally, the division that we use is floor division such that `10 * 9 / 8 = 90 / 8 = 11`.\n\nGiven an integer `n`, return _the clumsy factorial of_ `n`.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 7\n**Explanation:** 7 = 4 \\* 3 / 2 + 1\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** 12\n**Explanation:** 12 = 10 \\* 9 / 8 + 7 - 6 \\* 5 / 4 + 3 - 2 \\* 1\n\n**Constraints:**\n\n*   `1 <= n <= 104`",
        "difficulty": "Medium"
    },
    {
        "id": 1007,
        "question": "In a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\nWe may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.\n\nReturn the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.\n\nIf it cannot be done, return `-1`.\n\n**Example 1:**\n\n**Input:** tops = \\[2,1,2,4,2,2\\], bottoms = \\[5,2,6,2,3,2\\]\n**Output:** 2\n**Explanation:** \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n**Example 2:**\n\n**Input:** tops = \\[3,5,1,2,3\\], bottoms = \\[3,6,3,3,4\\]\n**Output:** -1\n**Explanation:** \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n**Constraints:**\n\n*   `2 <= tops.length <= 2 * 104`\n*   `bottoms.length == tops.length`\n*   `1 <= tops[i], bottoms[i] <= 6`",
        "difficulty": "Medium"
    },
    {
        "id": 1013,
        "question": "Given an array of integers `arr`, return `true` if we can partition the array into three **non-empty** parts with equal sums.\n\nFormally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`\n\n**Example 1:**\n\n**Input:** arr = \\[0,2,1,-6,6,-7,9,1,2,0,1\\]\n**Output:** true\n**Explanation:** 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\n**Example 2:**\n\n**Input:** arr = \\[0,2,1,-6,6,7,9,-1,2,0,1\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** arr = \\[3,3,6,5,-2,2,5,1,-9,4\\]\n**Output:** true\n**Explanation:** 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n\n**Constraints:**\n\n*   `3 <= arr.length <= 5 * 104`\n*   `-104 <= arr[i] <= 104`",
        "difficulty": "Easy"
    },
    {
        "id": 1020,
        "question": "You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.",
        "difficulty": "Medium"
    },
    {
        "id": 1027,
        "question": "Given an array `nums` of integers, return _the length of the longest arithmetic subsequence in_ `nums`.\n\n**Note** that:\n\n*   A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n*   A sequence `seq` is arithmetic if `seq[i + 1] - seq[i]` are all the same value (for `0 <= i < seq.length - 1`).\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,9,12\\]\n**Output:** 4\n**Explanation: ** The whole array is an arithmetic sequence with steps of length = 3.\n\n**Example 2:**\n\n**Input:** nums = \\[9,4,7,2,10\\]\n**Output:** 3\n**Explanation: ** The longest arithmetic subsequence is \\[4,7,10\\].\n\n**Example 3:**\n\n**Input:** nums = \\[20,1,15,3,10,5,8\\]\n**Output:** 4\n**Explanation: ** The longest arithmetic subsequence is \\[20,15,10,5\\].\n\n**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 500`",
        "difficulty": "Medium"
    },
    {
        "id": 1046,
        "question": "You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the weight of the last remaining stone_. If there are no stones left, return `0`.\n\n**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:** \nWe combine 7 and 8 to get 1 so the array converts to \\[2,4,1,1,1\\] then,\nwe combine 2 and 4 to get 2 so the array converts to \\[2,1,1,1\\] then,\nwe combine 2 and 1 to get 1 so the array converts to \\[1,1,1\\] then,\nwe combine 1 and 1 to get 0 so the array converts to \\[1\\] then that's the value of the last stone.\n\n**Example 2:**\n\n**Input:** stones = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 1000`",
        "difficulty": "Easy"
    },
    {
        "id": 1054,
        "question": "In a warehouse, there is a row of barcodes, where the `ith` barcode is `barcodes[i]`.\n\nRearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\n\n**Example 1:**\n\n**Input:** barcodes = \\[1,1,1,2,2,2\\]\n**Output:** \\[2,1,2,1,2,1\\]\n\n**Example 2:**\n\n**Input:** barcodes = \\[1,1,1,1,2,2,3,3\\]\n**Output:** \\[1,3,1,3,1,2,1,2\\]\n\n**Constraints:**\n\n*   `1 <= barcodes.length <= 10000`\n*   `1 <= barcodes[i] <= 10000`",
        "difficulty": "Medium"
    },
    {
        "id": 1060,
        "question": "Given an integer array `nums` which is sorted in **ascending order** and all of its elements are **unique** and given also an integer `k`, return the `kth` missing number starting from the leftmost number of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[4,7,9,10\\], k = 1\n**Output:** 5\n**Explanation:** The first missing number is 5.\n\n**Example 2:**\n\n**Input:** nums = \\[4,7,9,10\\], k = 3\n**Output:** 8\n**Explanation:** The missing numbers are \\[5,6,8,...\\], hence the third missing number is 8.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,4\\], k = 3\n**Output:** 6\n**Explanation:** The missing numbers are \\[3,5,6,7,...\\], hence the third missing number is 6.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `1 <= nums[i] <= 107`\n*   `nums` is sorted in **ascending order,** and all the elements are **unique**.\n*   `1 <= k <= 108`\n\n**Follow up:** Can you find a logarithmic time complexity (i.e., `O(log(n))`) solution?",
        "difficulty": "Medium"
    },
    {
        "id": 1065,
        "question": "Given a string `text` and an array of strings `words`, return _an array of all index pairs_ `[i, j]` _so that the substring_ `text[i...j]` _is in `words`_.\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).\n\n**Example 1:**\n\n**Input:** text =  \"thestoryofleetcodeandme \", words = \\[ \"story \", \"fleet \", \"leetcode \"\\]\n**Output:** \\[\\[3,7\\],\\[9,13\\],\\[10,17\\]\\]\n\n**Example 2:**\n\n**Input:** text =  \"ababa \", words = \\[ \"aba \", \"ab \"\\]\n**Output:** \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Explanation:** Notice that matches can overlap, see  \"aba \" is found in \\[0,2\\] and \\[2,4\\].\n\n**Constraints:**\n\n*   `1 <= text.length <= 100`\n*   `1 <= words.length <= 20`\n*   `1 <= words[i].length <= 50`\n*   `text` and `words[i]` consist of lowercase English letters.\n*   All the strings of `words` are **unique**.",
        "difficulty": "Easy"
    },
    {
        "id": 1066,
        "question": "On a campus represented as a 2D grid, there are `n` workers and `m` bikes, with `n <= m`. Each worker and bike is a 2D coordinate on this grid.\n\nWe assign one unique bike to each worker so that the sum of the **Manhattan distances** between each worker and their assigned bike is minimized.\n\nReturn `the minimum possible sum of Manhattan distances between each worker and their assigned bike`.\n\nThe **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.\n\n**Example 1:**\n\n**Input:** workers = \\[\\[0,0\\],\\[2,1\\]\\], bikes = \\[\\[1,2\\],\\[3,3\\]\\]\n**Output:** 6\n**Explanation:** \nWe assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.\n\n**Example 2:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\]\\], bikes = \\[\\[1,0\\],\\[2,2\\],\\[2,1\\]\\]\n**Output:** 4\n**Explanation:** \nWe first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.\n\n**Example 3:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\],\\[3,0\\],\\[4,0\\]\\], bikes = \\[\\[0,999\\],\\[1,999\\],\\[2,999\\],\\[3,999\\],\\[4,999\\]\\]\n**Output:** 4995\n\n**Constraints:**\n\n*   `n == workers.length`\n*   `m == bikes.length`\n*   `1 <= n <= m <= 10`\n*   `workers[i].length == 2`\n*   `bikes[i].length == 2`\n*   `0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000`\n*   All the workers and the bikes locations are **unique**.",
        "difficulty": "Medium"
    },
    {
        "id": 1100,
        "question": "Given a string `s` and an integer `k`, return _the number of substrings in_ `s` _of length_ `k` _with no repeated characters_.\n\n**Example 1:**\n\n**Input:** s =  \"havefunonleetcode \", k = 5\n**Output:** 6\n**Explanation:** There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.\n\n**Example 2:**\n\n**Input:** s =  \"home \", k = 5\n**Output:** 0\n**Explanation:** Notice k can be larger than the length of s. In this case, it is not possible to find any substring.\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n*   `1 <= k <= 104`",
        "difficulty": "Medium"
    },
    {
        "id": 1121,
        "question": "Given an integer array `nums` sorted in non-decreasing order and an integer `k`, return `true` _if this array can be divided into one or more disjoint increasing subsequences of length at least_ `k`_, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,2,3,3,4,4\\], k = 3\n**Output:** true\n**Explanation:** The array can be divided into two subsequences \\[1,2,3,4\\] and \\[2,3,4\\] with lengths at least 3 each.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,6,7,8\\], k = 3\n**Output:** false\n**Explanation:** There is no way to divide the array using the conditions required.\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\n*   `nums` is sorted in non-decreasing order.",
        "difficulty": "Hard"
    },
    {
        "id": 1122,
        "question": "Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n\nSort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that do not appear in `arr2` should be placed at the end of `arr1` in **ascending** order.\n\n**Example 1:**\n\n**Input:** arr1 = \\[2,3,1,3,2,4,6,7,9,2,19\\], arr2 = \\[2,1,4,3,9,6\\]\n**Output:** \\[2,2,2,1,4,3,3,9,6,7,19\\]\n\n**Example 2:**\n\n**Input:** arr1 = \\[28,6,22,8,44,17\\], arr2 = \\[22,28,8,6\\]\n**Output:** \\[22,28,8,6,17,44\\]\n\n**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 1000`\n*   `0 <= arr1[i], arr2[i] <= 1000`\n*   All the elements of `arr2` are **distinct**.\n*   Each `arr2[i]` is in `arr1`.",
        "difficulty": "Easy"
    },
    {
        "id": 1136,
        "question": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`.\n\nIn one semester, you can take **any number** of courses as long as you have taken all the prerequisites in the **previous** semester for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. If there is no way to take all the courses, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\]\n**Output:** 2\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 1 and 2.\nIn the second semester, you can take course 3.\n\n**Example 2:**\n\n**Input:** n = 3, relations = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1\n**Explanation:** No course can be studied because they are prerequisites of each other.\n\n**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `1 <= relations.length <= 5000`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.",
        "difficulty": "Medium"
    },
    {
        "id": 1160,
        "question": "You are given an array of strings `words` and a string `chars`.\n\nA string is **good** if it can be formed by characters from chars (each character can only be used once).\n\nReturn _the sum of lengths of all good strings in words_.\n\n**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"bt \", \"hat \", \"tree \"\\], chars =  \"atach \"\n**Output:** 6\n**Explanation:** The strings that can be formed are  \"cat \" and  \"hat \" so the answer is 3 + 3 = 6.\n\n**Example 2:**\n\n**Input:** words = \\[ \"hello \", \"world \", \"leetcode \"\\], chars =  \"welldonehoneyr \"\n**Output:** 10\n**Explanation:** The strings that can be formed are  \"hello \" and  \"world \" so the answer is 5 + 5 = 10.\n\n**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length, chars.length <= 100`\n*   `words[i]` and `chars` consist of lowercase English letters.",
        "difficulty": "Easy"
    },
    {
        "id": 1165,
        "question": "There is a special keyboard with **all keys in a single row**.\n\nGiven a string `keyboard` of length `26` indicating the layout of the keyboard (indexed from `0` to `25`). Initially, your finger is at index `0`. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index `i` to index `j` is `|i - j|`.\n\nYou want to type a string `word`. Write a function to calculate how much time it takes to type it with one finger.\n\n**Example 1:**\n\n**Input:** keyboard =  \"abcdefghijklmnopqrstuvwxyz \", word =  \"cba \"\n**Output:** 4\n**Explanation:** The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.\nTotal time = 2 + 1 + 1 = 4. \n\n**Example 2:**\n\n**Input:** keyboard =  \"pqrstuvwxyzabcdefghijklmno \", word =  \"leetcode \"\n**Output:** 73\n\n**Constraints:**\n\n*   `keyboard.length == 26`\n*   `keyboard` contains each English lowercase letter exactly once in some order.\n*   `1 <= word.length <= 104`\n*   `word[i]` is an English lowercase letter.",
        "difficulty": "Easy"
    },
    {
        "id": 1175,
        "question": "Return the number of permutations of 1 to `n` so that prime numbers are at prime indices (1-indexed.)\n\n_(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)_\n\nSince the answer may be large, return the answer **modulo `10^9 + 7`**.\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 12\n**Explanation:** For example \\[1,2,5,4,3\\] is a valid permutation, but \\[5,2,3,4,1\\] is not because the prime number 5 is at index 1.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 682289015\n\n**Constraints:**\n\n*   `1 <= n <= 100`",
        "difficulty": "Easy"
    },
    {
        "id": 1189,
        "question": "Given a string `text`, you want to use the characters of `text` to form as many instances of the word **\"balloon \"** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.\n\n**Example 1:**\n\n**Input:** text =  \"nlaebolko \"\n**Output:** 1\n\n**Example 2:**\n\n**Input:** text =  \"loonbalxballpoon \"\n**Output:** 2\n\n**Example 3:**\n\n**Input:** text =  \"leetcode \"\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= text.length <= 104`\n*   `text` consists of lower case English letters only.",
        "difficulty": "Easy"
    },
    {
        "id": 1190,
        "question": "You are given a string `s` that consists of lower case English letters and brackets.\n\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\n\nYour result should **not** contain any brackets.\n\n**Example 1:**\n\n**Input:** s =  \"(abcd) \"\n**Output:**  \"dcba \"\n\n**Example 2:**\n\n**Input:** s =  \"(u(love)i) \"\n**Output:**  \"iloveu \"\n**Explanation:** The substring  \"love \" is reversed first, then the whole string is reversed.\n\n**Example 3:**\n\n**Input:** s =  \"(ed(et(oc))el) \"\n**Output:**  \"leetcode \"\n**Explanation:** First, we reverse the substring  \"oc \", then  \"etco \", and finally, the whole string.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` only contains lower case English characters and parentheses.\n*   It is guaranteed that all parentheses are balanced.",
        "difficulty": "Medium"
    },
    {
        "id": 1209,
        "question": "You are given a string `s` and an integer `k`, a `k` **duplicate removal** consists of choosing `k` adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together.\n\nWe repeatedly make `k` **duplicate removals** on `s` until we no longer can.\n\nReturn _the final string after all such duplicate removals have been made_. It is guaranteed that the answer is **unique**.\n\n**Example 1:**\n\n**Input:** s =  \"abcd \", k = 2\n**Output:**  \"abcd \"\n**Explanation:** There's nothing to delete.\n\n**Example 2:**\n\n**Input:** s =  \"deeedbbcccbdaa \", k = 3\n**Output:**  \"aa \"\n**Explanation:** \nFirst delete  \"eee \" and  \"ccc \", get  \"ddbbbdaa \"\nThen delete  \"bbb \", get  \"dddaa \"\nFinally delete  \"ddd \", get  \"aa \"\n\n**Example 3:**\n\n**Input:** s =  \"pbbcggttciiippooaais \", k = 2\n**Output:**  \"ps \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `2 <= k <= 104`\n*   `s` only contains lowercase English letters.",
        "difficulty": "Medium"
    },
    {
        "id": 1221,
        "question": "**Balanced** strings are those that have an equal quantity of `'L'` and `'R'` characters.\n\nGiven a **balanced** string `s`, split it into some number of substrings such that:\n\n*   Each substring is balanced.\n\nReturn _the **maximum** number of balanced strings you can obtain._\n\n**Example 1:**\n\n**Input:** s =  \"RLRRLLRLRL \"\n**Output:** 4\n**Explanation:** s can be split into  \"RL \",  \"RRLL \",  \"RL \",  \"RL \", each substring contains same number of 'L' and 'R'.\n\n**Example 2:**\n\n**Input:** s =  \"RLRRRLLRLL \"\n**Output:** 2\n**Explanation:** s can be split into  \"RL \",  \"RRRLLRLL \", each substring contains same number of 'L' and 'R'.\nNote that s cannot be split into  \"RL \",  \"RR \",  \"RL \",  \"LR \",  \"LL \", because the 2nd and 5th substrings are not balanced.\n\n**Example 3:**\n\n**Input:** s =  \"LLLLRRRR \"\n**Output:** 1\n**Explanation:** s can be split into  \"LLLLRRRR \".\n\n**Constraints:**\n\n*   `2 <= s.length <= 1000`\n*   `s[i]` is either `'L'` or `'R'`.\n*   `s` is a **balanced** string.",
        "difficulty": "Easy"
    },
    {
        "id": 1229,
        "question": "Given the availability time slots arrays `slots1` and `slots2` of two people and a meeting duration `duration`, return the **earliest time slot** that works for both of them and is of duration `duration`.\n\nIf there is no common time slot that satisfies the requirements, return an **empty array**.\n\nThe format of a time slot is an array of two elements `[start, end]` representing an inclusive time range from `start` to `end`.\n\nIt is guaranteed that no two availability slots of the same person intersect with each other. That is, for any two time slots `[start1, end1]` and `[start2, end2]` of the same person, either `start1 > end2` or `start2 > end1`.\n\n**Example 1:**\n\n**Input:** slots1 = \\[\\[10,50\\],\\[60,120\\],\\[140,210\\]\\], slots2 = \\[\\[0,15\\],\\[60,70\\]\\], duration = 8\n**Output:** \\[60,68\\]\n\n**Example 2:**\n\n**Input:** slots1 = \\[\\[10,50\\],\\[60,120\\],\\[140,210\\]\\], slots2 = \\[\\[0,15\\],\\[60,70\\]\\], duration = 12\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= slots1.length, slots2.length <= 104`\n*   `slots1[i].length, slots2[i].length == 2`\n*   `slots1[i][0] < slots1[i][1]`\n*   `slots2[i][0] < slots2[i][1]`\n*   `0 <= slots1[i][j], slots2[i][j] <= 109`\n*   `1 <= duration <= 106`",
        "difficulty": "Medium"
    }
]